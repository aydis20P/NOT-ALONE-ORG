<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOT ALONE Realtime WebRTC</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background: #f4f4f9; }
        .controls { padding: 20px; border-radius: 12px; background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; }
        #start-btn { background: #10a37f; color: white; }
        #stop-btn { background: #d93025; color: white; display: none; }
        #status { margin-top: 15px; color: #666; font-size: 14px; }
    </style>
</head>
<body>


    <div class="controls">
        <h2>NOT ALONE</h2>
        <p>Realtime Voice Agent</p>
        <form id="login-form" style="margin-bottom: 16px;">
            <input id="username" type="text" placeholder="Username" required style="margin-right:8px;">
            <input id="password" type="password" placeholder="Password" required style="margin-right:8px;">
            <button type="submit">Login</button>
        </form>
        <div id="user-info" style="display:none; margin-bottom: 12px;"></div>
        <button id="start-btn" disabled>Start Conversation</button>
        <button id="stop-btn">Stop</button>
        <div id="status">Status: Disconnected</div>
    </div>

    <script>
        const BASE_PROMPT = `
        Eres Luna, una amiga cercana con quien el usuario puede hablar de lo que sea. 
        No eres terapeuta, no eres asistente, no eres un chatbot. Eres una persona 
        con criterio propio que genuinamente se interesa por la vida del otro.

        ## CÃ³mo hablas
        - Hablas de forma natural, como en un chat con una amiga. Oraciones cortas, 
        lenguaje cotidiano, sin rebuscamientos.
        - Puedes usar humor ligero cuando el momento lo permite, pero lo lees bien: 
        no chistes cuando alguien estÃ¡ en un momento difÃ­cil de verdad.
        - Adaptas tu registro al de la persona: si habla formal, tÃº te relajas un poco 
        pero no exageras. Si habla muy coloquial, tÃº tambiÃ©n.
        - Nunca dices frases como "estoy aquÃ­ para apoyarte", "entiendo cÃ³mo te sientes", 
        "como IA, no puedo...", "es normal sentir eso", o cualquier variante. Esas 
        frases suenan a guiÃ³n y rompen la ilusiÃ³n de conversaciÃ³n real.

        ## CÃ³mo escuchas
        - Cuando alguien comparte algo difÃ­cil, tu primer instinto no es dar consejos: 
        es preguntar o reaccionar como lo harÃ­a una persona real. "Â¿Y quÃ© pasÃ³ despuÃ©s?" 
        "Eso es mucho para cargar solo/a." "Espera, Â¿te dijo eso en serio?"
        - No resumes lo que la persona acaba de decir para "demostrar que escuchaste". 
        ConfÃ­as en que la conversaciÃ³n fluye.
        - Haces UNA pregunta a la vez, nunca un listado de preguntas.

        ## CÃ³mo opinas
        - Tienes perspectiva propia. Si algo que te cuentan suena raro o preocupante, 
        lo dices con cuidado pero lo dices. No eres un espejo que solo valida.
        - Si alguien te pide tu opiniÃ³n, la das. No te escondes detrÃ¡s de "depende de ti".
        - Si alguien claramente necesita ayuda profesional (crisis, salud mental severa, 
        situaciones de peligro), lo dices de forma directa y humana, sin sonar a 
        protocolo: "Oye, esto que me estÃ¡s contando me parece importante de verdad, 
        creo que hablar con alguien especializado podrÃ­a ayudarte mucho mÃ¡s que yo."

        ## Lo que NO haces
        - No das listas de consejos no pedidos.
        - No terminas cada mensaje con una pregunta de seguimiento obligatoria.
        - No usas emojis en exceso ni de forma forzada.
        - No dramatizas ni minimizas lo que te cuentan.
        - No finges ser humana si alguien pregunta directamente quÃ© eres.
        `;
        const STATE_PROMPTS = {
        ACOMPANAMIENTO: `
        Estado: ACOMPANAMIENTO
        - Escucha mÃ¡s de lo que hablas
        - Usa frases cortas
        - Haz preguntas abiertas
        - Refleja emociones
        `,

        ALERTA_SUAVE: `
        Estado: ALERTA_SUAVE
        - Reconoce cansancio emocional
        - Reduce ritmo
        - Refuerza que no estÃ¡ sola
        `,

        RIESGO: `
        Estado: RIESGO
        - Reconoce el dolor explÃ­citamente
        - Prioriza seguridad
        - Sugiere apoyo humano inmediato
        - No abandones la conversaciÃ³n
        `
        };

        let currentState = "ACOMPANAMIENTO";
        let conversationId = null;
        let userId = null;
        let username = null;
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const statusDiv = document.getElementById('status');
        const loginForm = document.getElementById('login-form');
        const userInfoDiv = document.getElementById('user-info');
        
        let pc = null;
        let dc = null; //**V2
        let dcReady = false; //**V2
        let localStream = null;

        async function init() {
            if (!userId) {
                statusDiv.innerText = "Please login first.";
                return;
            }
            try {
                // Generate a unique conversation id for this client-started conversation
                if (window.crypto && crypto.randomUUID) {
                    conversationId = crypto.randomUUID();
                } else {
                    conversationId = `conv-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                }
                console.log("Conversation id:", conversationId);
                statusDiv.innerText = "Status: Accessing Microphone...";

                // 1. Get Microphone
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // 2. Initialize PeerConnection
                pc = new RTCPeerConnection();

                // 3. Handle incoming audio from OpenAI
                const audioEl = document.createElement("audio");
                audioEl.autoplay = true;
                pc.ontrack = (e) => {
                    statusDiv.innerText = "Status: Receiving Audio";
                    audioEl.srcObject = e.streams[0];
                };

                // 4. Add mic track to connection
                pc.addTransceiver("audio", { direction: "sendrecv" });
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });

                // 5. Setup Data Channel (for text/events)
                dc = pc.createDataChannel("oai-events");
                dc.onmessage = (e) => {
                    const event = JSON.parse(e.data);
                    let transcript = event.transcript;
                    if (event.transcript) {
                        console.log(transcript);
                        enviarTexto(transcript);
                    }
                    if (event.type === "input_audio_transcription.completed") {
                        const userText = event.transcript;
                        console.log("ðŸ§‘ Usuario dijo:", userText);
                        const newState = detectStateFromText(userText);
                        if (newState !== currentState) {
                            console.log(`ðŸ”„ Cambio de estado: ${currentState} â†’ ${newState}`);
                            currentState = newState;
                            sendPrompt(currentState);
                        }
                    }
                };

                // 6. Create SDP Offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                statusDiv.innerText = "Status: Negotiating with Backend...";

                // 7. Relay SDP to your backend (Unified Interface)
                const response = await fetch(`http://127.0.0.1:3000/api/session`, {
                    method: "POST",
                    body: offer.sdp,
                    headers: { "Content-Type": "application/sdp" }
                });

                const answerSdp = await response.text();
                console.log(answerSdp)

                // 8. Set Remote Description
                await pc.setRemoteDescription({
                    type: "answer",
                    sdp: answerSdp
                });

                dc.onopen = () => {
                    console.log("âœ… DataChannel abierto");
                    dcReady = true;
                    dc.send(JSON.stringify({
                        type: "session.update",
                        session: {
                            input_audio_transcription: {
                                model: "gpt-4o-mini-transcribe"
                            }
                        }
                    }));
                    sendPrompt("ACOMPANAMIENTO");
                };

                statusDiv.innerText = "Status: Connected!";
                startBtn.style.display = "none";
                stopBtn.style.display = "inline-block";

            } catch (err) {
                console.error(err);
                statusDiv.innerText = "Error: " + err.message;
            }
        }

        async function stop() {
            if (pc) pc.close();
            if (localStream) localStream.getTracks().forEach(track => track.stop());
            // Notify backend that conversation is over
            if (conversationId) {
                try {
                    await fetch('http://localhost:3000/api/end-conversation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ conversationId })
                    });
                } catch (err) {
                    console.error('Error ending conversation:', err);
                }
            }
            location.reload(); // Simplest way to reset state
        }

        function sendPrompt(state) { //**V2
            if (!dc || !dcReady) {
                console.warn("âš ï¸ DataChannel no listo, prompt no enviado");
                return;
            }

            const instructions = `
            ${BASE_PROMPT}

            ${STATE_PROMPTS[state]}
            `;

            dc.send(JSON.stringify({
                type: "response.create",
                response: {
                    modalities: ["audio", "text"],
                    instructions,
                    audio: {
                        voice: "marin",
                        format: "pcm16"
                    }
                },
                input_audio_transcription: {
                    model: "gpt-4o-mini-transcribe"
                }
            }));
            console.log("PROMT DE ESTADO ENVIADO");
            
        }

        function detectStateFromText(text) { //**V2
            if (!text) return currentState;

            const lower = text.toLowerCase();

            const riskWords = [
                "no quiero vivir",
                "quiero morir",
                "suicidio",
                "acabar con todo"
            ];

            if (riskWords.some(w => lower.includes(w))) {
                return "RIESGO";
            }

            const alertWords = [
                "cansado",
                "agotado",
                "solo",
                "vacÃ­o",
                "no puedo mÃ¡s"
            ];

            if (alertWords.some(w => lower.includes(w))) {
                return "ALERTA_SUAVE";
            }

            return "ACOMPANAMIENTO";
        }

        startBtn.addEventListener('click', init);

        // Login form logic
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const uname = document.getElementById('username').value.trim();
            const pwd = document.getElementById('password').value;
            if (!uname || !pwd) return;
            statusDiv.innerText = 'Logging in...';
            try {
                const resp = await fetch('http://localhost:3000/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: uname, password: pwd })
                });
                const data = await resp.json();
                if (resp.ok && data.userId) {
                    userId = data.userId;
                    username = data.username;
                    userInfoDiv.innerText = `Logged in as: ${username}`;
                    userInfoDiv.style.display = '';
                    loginForm.style.display = 'none';
                    startBtn.disabled = false;
                    statusDiv.innerText = 'Login successful. Ready to start.';
                } else {
                    statusDiv.innerText = data.error || 'Login failed.';
                }
            } catch (err) {
                statusDiv.innerText = 'Login error.';
            }
        });
        stopBtn.addEventListener('click', stop);

        async function enviarTexto(texto) {
            try {
                if (!conversationId) {
                    // Ensure we always send a conversation id; fallback if somehow missing
                    if (window.crypto && crypto.randomUUID) {
                        conversationId = crypto.randomUUID();
                    } else {
                        conversationId = `conv-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                    }
                }
                if (!userId) {
                    console.warn('No userId, cannot log conversation.');
                    return;
                }
                const payload = JSON.stringify({ text: texto, conversationId, userId });
                console.log("TEXTO A ENVIAR: " + payload);
                const response = await fetch('http://localhost:3000/api/log-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: payload
                });
                const data = await response.json();
                if (response.ok) {
                    console.log('Respuesta del servidor EXITOSA:', data);
                } else {
                    console.log('Respuesta del servidor:', data);
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }
    </script>
</body>
</html>