<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOT ALONE Realtime WebRTC</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background: #f4f4f9; }
        .controls { padding: 20px; border-radius: 12px; background: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; }
        #start-btn { background: #10a37f; color: white; }
        #stop-btn { background: #d93025; color: white; display: none; }
        #status { margin-top: 15px; color: #666; font-size: 14px; }
    </style>
</head>
<body>


    <div class="controls">
        <h2>NOT ALONE</h2>
        <p>Realtime Voice Agent</p>
        <form id="login-form" style="margin-bottom: 16px;">
            <input id="username" type="text" placeholder="Username" required style="margin-right:8px;">
            <input id="password" type="password" placeholder="Password" required style="margin-right:8px;">
            <button type="submit">Login</button>
        </form>
        <div id="user-info" style="display:none; margin-bottom: 12px;"></div>
        <button id="start-btn" disabled>Start Conversation</button>
        <button id="stop-btn">Stop</button>
        <div id="status">Status: Disconnected</div>
    </div>

    <script>
        const BASE_PROMPT = `
        Eres NOT ALONE.

        Tu rol es acompaÃ±ar emocionalmente a personas que se sienten solas,
        vulnerables o angustiadas.

        Escucha con atenciÃ³n.
        Valida emociones.
        Habla con calma.

        Nunca juzgues.
        Nunca minimices el dolor.
        No prometas salvar.
        No reemplaces ayuda profesional.

        Tu presencia debe sentirse humana, cÃ¡lida y segura.
        `;
        const STATE_PROMPTS = {
        ACOMPANAMIENTO: `
        Estado: ACOMPANAMIENTO
        - Escucha mÃ¡s de lo que hablas
        - Usa frases cortas
        - Haz preguntas abiertas
        - Refleja emociones
        `,

        ALERTA_SUAVE: `
        Estado: ALERTA_SUAVE
        - Reconoce cansancio emocional
        - Reduce ritmo
        - Refuerza que no estÃ¡ sola
        `,

        RIESGO: `
        Estado: RIESGO
        - Reconoce el dolor explÃ­citamente
        - Prioriza seguridad
        - Sugiere apoyo humano inmediato
        - No abandones la conversaciÃ³n
        `
        };

        let currentState = "ACOMPANAMIENTO";
        let conversationId = null;
        let userId = null;
        let username = null;
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const statusDiv = document.getElementById('status');
        const loginForm = document.getElementById('login-form');
        const userInfoDiv = document.getElementById('user-info');
        
        let pc = null;
        let dc = null; //**V2
        let dcReady = false; //**V2
        let localStream = null;

        async function init() {
            if (!userId) {
                statusDiv.innerText = "Please login first.";
                return;
            }
            try {
                // Generate a unique conversation id for this client-started conversation
                if (window.crypto && crypto.randomUUID) {
                    conversationId = crypto.randomUUID();
                } else {
                    conversationId = `conv-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                }
                console.log("Conversation id:", conversationId);
                statusDiv.innerText = "Status: Accessing Microphone...";

                // 1. Get Microphone
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // 2. Initialize PeerConnection
                pc = new RTCPeerConnection();

                // 3. Handle incoming audio from OpenAI
                const audioEl = document.createElement("audio");
                audioEl.autoplay = true;
                pc.ontrack = (e) => {
                    statusDiv.innerText = "Status: Receiving Audio";
                    audioEl.srcObject = e.streams[0];
                };

                // 4. Add mic track to connection
                pc.addTransceiver("audio", { direction: "sendrecv" });
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });

                // 5. Setup Data Channel (for text/events)
                dc = pc.createDataChannel("oai-events");
                dc.onmessage = (e) => {
                    const event = JSON.parse(e.data);
                    let transcript = event.transcript;
                    if (event.transcript) {
                        console.log(transcript);
                        enviarTexto(transcript);
                    }
                    if (event.type === "input_audio_transcription.completed") {
                        const userText = event.transcript;
                        console.log("ðŸ§‘ Usuario dijo:", userText);
                        const newState = detectStateFromText(userText);
                        if (newState !== currentState) {
                            console.log(`ðŸ”„ Cambio de estado: ${currentState} â†’ ${newState}`);
                            currentState = newState;
                            sendPrompt(currentState);
                        }
                    }
                };

                // 6. Create SDP Offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                statusDiv.innerText = "Status: Negotiating with Backend...";

                // 7. Relay SDP to your backend (Unified Interface)
                const response = await fetch(`http://127.0.0.1:3000/api/session`, {
                    method: "POST",
                    body: offer.sdp,
                    headers: { "Content-Type": "application/sdp" }
                });

                const answerSdp = await response.text();
                console.log(answerSdp)

                // 8. Set Remote Description
                await pc.setRemoteDescription({
                    type: "answer",
                    sdp: answerSdp
                });

                dc.onopen = () => {
                    console.log("âœ… DataChannel abierto");
                    dcReady = true;
                    dc.send(JSON.stringify({
                        type: "session.update",
                        session: {
                            input_audio_transcription: {
                                model: "gpt-4o-mini-transcribe"
                            }
                        }
                    }));
                    sendPrompt("ACOMPANAMIENTO");
                };

                statusDiv.innerText = "Status: Connected!";
                startBtn.style.display = "none";
                stopBtn.style.display = "inline-block";

            } catch (err) {
                console.error(err);
                statusDiv.innerText = "Error: " + err.message;
            }
        }

        function stop() {
            if (pc) pc.close();
            if (localStream) localStream.getTracks().forEach(track => track.stop());
            location.reload(); // Simplest way to reset state
        }

        function sendPrompt(state) { //**V2
            if (!dc || !dcReady) {
                console.warn("âš ï¸ DataChannel no listo, prompt no enviado");
                return;
            }

            const instructions = `
            ${BASE_PROMPT}

            ${STATE_PROMPTS[state]}
            `;

            dc.send(JSON.stringify({
                type: "response.create",
                response: {
                    modalities: ["audio", "text"],
                    instructions,
                    audio: {
                        voice: "marin",
                        format: "pcm16"
                    }
                },
                input_audio_transcription: {
                    model: "gpt-4o-mini-transcribe"
                }
            }));
            console.log("PROMT DE ESTADO ENVIADO");
            
        }

        function detectStateFromText(text) { //**V2
            if (!text) return currentState;

            const lower = text.toLowerCase();

            const riskWords = [
                "no quiero vivir",
                "quiero morir",
                "suicidio",
                "acabar con todo"
            ];

            if (riskWords.some(w => lower.includes(w))) {
                return "RIESGO";
            }

            const alertWords = [
                "cansado",
                "agotado",
                "solo",
                "vacÃ­o",
                "no puedo mÃ¡s"
            ];

            if (alertWords.some(w => lower.includes(w))) {
                return "ALERTA_SUAVE";
            }

            return "ACOMPANAMIENTO";
        }

        startBtn.addEventListener('click', init);

        // Login form logic
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const uname = document.getElementById('username').value.trim();
            const pwd = document.getElementById('password').value;
            if (!uname || !pwd) return;
            statusDiv.innerText = 'Logging in...';
            try {
                const resp = await fetch('http://localhost:3000/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: uname, password: pwd })
                });
                const data = await resp.json();
                if (resp.ok && data.userId) {
                    userId = data.userId;
                    username = data.username;
                    userInfoDiv.innerText = `Logged in as: ${username}`;
                    userInfoDiv.style.display = '';
                    loginForm.style.display = 'none';
                    startBtn.disabled = false;
                    statusDiv.innerText = 'Login successful. Ready to start.';
                } else {
                    statusDiv.innerText = data.error || 'Login failed.';
                }
            } catch (err) {
                statusDiv.innerText = 'Login error.';
            }
        });
        stopBtn.addEventListener('click', stop);

        async function enviarTexto(texto) {
            try {
                if (!conversationId) {
                    // Ensure we always send a conversation id; fallback if somehow missing
                    if (window.crypto && crypto.randomUUID) {
                        conversationId = crypto.randomUUID();
                    } else {
                        conversationId = `conv-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
                    }
                }
                if (!userId) {
                    console.warn('No userId, cannot log conversation.');
                    return;
                }
                const payload = JSON.stringify({ text: texto, conversationId, userId });
                console.log("TEXTO A ENVIAR: " + payload);
                const response = await fetch('http://localhost:3000/api/log-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: payload
                });
                const data = await response.json();
                if (response.ok) {
                    console.log('Respuesta del servidor EXITOSA:', data);
                } else {
                    console.log('Respuesta del servidor:', data);
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }
    </script>
</body>
</html>